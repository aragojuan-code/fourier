<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"/>
<title>Ã“rbitas â€“ minimal 2 filas</title>
<style>
  :root{
    --bg:#000; --panel:rgba(16,23,34,.92); --ink:#e6eef7; --muted:#9fb3c9; --shadow:rgba(0,0,0,.35);
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{position:fixed;inset:0;display:flex;flex-direction:column}
  /* barra de botones en 2 filas (wrap) */
  .top{
    position:relative; z-index:5; display:flex; flex-wrap:wrap; gap:10px; padding:10px 12px;
    background:linear-gradient(180deg, rgba(0,0,0,.75), rgba(0,0,0,.2));
    backdrop-filter:saturate(1.2) blur(4px);
  }
  .chip{
    min-width:44px; height:44px; border-radius:14px; padding:0 10px;
    background:var(--panel); border:1px solid rgba(230,238,247,.12);
    display:flex; align-items:center; justify-content:center; gap:6px;
    box-shadow:0 6px 16px var(--shadow); font-size:18px; cursor:pointer; user-select:none;
  }
  .chip small{font-size:12px; color:var(--muted)}
  .chip.active{outline:2px solid rgba(255,255,255,.35)}
  .chip:active{transform:scale(.98)}
  .stage{position:relative; flex:1; overflow:hidden; touch-action:none;}
  canvas{position:absolute; inset:0; width:100%; height:100%; display:block; background:#000}
</style>
</head>
<body>
<div class="wrap">
  <div class="top" id="toolbar">
    <!-- fila 1 -->
    <div class="chip" id="btnCircles" title="CÃ­rculos 3/6/12">â—â—â—</div>
    <div class="chip" id="btnShape"   title="Figura">â™¥ï¸</div>
    <div class="chip" id="btnSpeed"   title="Velocidad">ğŸ¢</div>
    <div class="chip" id="btnTrail"   title="Trayectoria (0/1/cierre)">â—”</div>
    <div class="chip" id="btnPhase"   title="Fase por ciclo (+10Â°)">Ï†</div>
    <!-- fila 2 -->
    <div class="chip" id="btnAmp"     title="TamaÃ±o por ciclo (Ã—1.05)">r</div>
    <div class="chip" id="btnZoomC"   title="Zoom por ciclo (Ã—1.05)">ğŸ”</div>
    <div class="chip" id="btnColorC"  title="Color por ciclo">ğŸ¨</div>
    <div class="chip" id="btnOff1"    title="Desactivar 1Âº cÃ­rculo"><small>1</small>â›”</div>
    <div class="chip" id="btnReset"   title="Reset">â†º</div>
    <div class="chip" id="btnPlay"    title="Play/Pausa">âšâš</div>
    <div class="chip" id="btnSave"    title="Guardar PNG">ğŸ’¾</div>
  </div>

  <div class="stage"><canvas id="cv"></canvas></div>
</div>

<script>
/* ========= Estado ========= */
const cvs = document.getElementById('cv'), ctx = cvs.getContext('2d');
const dpi = devicePixelRatio||1;
let W=0,H=0;

let t=0, running=true;
let zoom=1; // no hay zoom manual
let showTrace=true, trailMode=1; // 0: off, 1: 1 ciclo, 2: hasta cierre largo
let trace=[], traceMax=8000;
let currentColor='#e6eef7';

let circlesPresets=[3,6,12], circlesIdx=1, circlesN=circlesPresets[circlesIdx];
let speedPresets=[0.02,0.10,0.25], speedIdx=1, speed=speedPresets[speedIdx];

const SHAPES=['heart','star','triangle','square','pentagon','hexagon','infinity','circle','batman'];
const SHICON={heart:'â™¥ï¸',star:'â˜…',triangle:'â–²',square:'â– ',pentagon:'â¬Ÿ',hexagon:'â¬¢',infinity:'âˆ',circle:'â—',batman:'ğŸ¦‡'};
let shapeIdx=0;

let points=[], order=[];
let disableFirst=false;

const perCycle={
  phaseEnabled:true,  phaseStepDeg:10,               // +10Â°
  ampEnabled:false,   ampScaleStep:1.05,             // Ã—1.05
  zoomEnabled:false,  zoomStep:1.05,                 // Ã—1.05
  colorEnabled:true
};
// control de â€œcierre largoâ€ por fase acumulada
let cumPhaseDeg = 0;        // acumula la fase aplicada (mod 360)
let lastCycle = 0;          // ciclos base
let startPt = null;         // para cierre geomÃ©trico cuando phaseEnabled=false

/* ========= Util ========= */
const $ = s=>document.querySelector(s);
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function deg2rad(d){return d*Math.PI/180}

/* ========= TamaÃ±o ========= */
function resize(){
  const r=cvs.parentElement.getBoundingClientRect();
  const w=Math.max(1,Math.floor(r.width*dpi));
  const h=Math.max(1,Math.floor(r.height*dpi));
  if(Math.abs(cvs.width-w)<1 && Math.abs(cvs.height-h)<8) return;
  W=w;H=h;cvs.width=W;cvs.height=H;
}
resize(); addEventListener('resize', ()=>resize(), {passive:true});

/* ========= Figuras ========= */
function resamplePolyline(verts,N,close=true){
  const P=verts.slice(); if(close) P.push(verts[0]);
  const L=[0]; let sum=0;
  for(let i=1;i<P.length;i++){ sum+=Math.hypot(P[i][0]-P[i-1][0],P[i][1]-P[i-1][1]); L.push(sum); }
  const out=[];
  for(let i=0;i<N;i++){
    const d=i/N*sum; let j=1; while(j<L.length && L[j]<d) j++;
    const u=(d-L[j-1])/(L[j]-L[j-1]||1);
    out.push({x:P[j-1][0]*(1-u)+P[j][0]*u, y:P[j-1][1]*(1-u)+P[j][1]*u});
  }
  return out;
}
function poly(sides,N){
  const R=Math.min(W,H)*0.35, cx=W/2, cy=H/2, V=[];
  for(let i=0;i<sides;i++){ const a=-Math.PI/2 + i*2*Math.PI/sides; V.push([cx+R*Math.cos(a), cy+R*Math.sin(a)]); }
  return resamplePolyline(V,N,true);
}
function star5(N){
  const cx=W/2, cy=H/2, R=Math.min(W,H)*0.35, r=R*0.4, V=[];
  for(let i=0;i<10;i++){ const a=-Math.PI/2+i*(2*Math.PI/10); V.push([cx+(i%2? r:R)*Math.cos(a), cy+(i%2? r:R)*Math.sin(a)]); }
  return resamplePolyline(V,N,true);
}
function heart(N){
  const s=Math.min(W,H)*0.03, cx=W/2, cy=H/2, pts=[];
  for(let i=0;i<N;i++){ const tt=i/N*2*Math.PI;
    const x=16*Math.pow(Math.sin(tt),3);
    const y=13*Math.cos(tt)-5*Math.cos(2*tt)-2*Math.cos(3*tt)-Math.cos(4*tt);
    pts.push({x:cx+x*s,y:cy-y*s}); }
  return pts;
}
function infinityC(N){
  const a=Math.min(W,H)*0.25, cx=W/2, cy=H/2, pts=[];
  for(let i=0;i<N;i++){ const tt=i/N*2*Math.PI, d=1+Math.sin(tt)*Math.sin(tt);
    pts.push({x:cx+a*Math.cos(tt)/d, y:cy+a*Math.sin(tt)*Math.cos(tt)/d}); }
  return pts;
}
function circle(N){
  const R=Math.min(W,H)*0.35, cx=W/2, cy=H/2, pts=[];
  for(let i=0;i<N;i++){ const a=i/N*2*Math.PI; pts.push({x:cx+R*Math.cos(a), y:cy+R*Math.sin(a)}); }
  return pts;
}
function batmanS(N){
  const base=[[-1,0],[-.8,.22],[-.6,.1],[-.5,.3],[-.4,.1],[-.3,.22],[-.2,.05],[-.15,.22],[-.1,.1],[-.07,.36],[0,.52],[.07,.36],[.1,.1],[.15,.22],[.2,.05],[.3,.22],[.4,.1],[.5,.3],[.6,.1],[.8,.22],[1,0],[.8,-.22],[.6,-.1],[.5,-.3],[.4,-.1],[.3,-.22],[.2,-.05],[.15,-.26],[.1,-.1],[0,-.42],[-.1,-.1],[-.15,-.26],[-.2,-.05],[-.3,-.22],[-.4,-.1],[-.5,-.3],[-.6,-.1],[-.8,-.22]];
  const s=Math.min(W,H)*0.35, cx=W/2, cy=H/2; const V=base.map(([x,y])=>[cx+x*s, cy+y*s]);
  return resamplePolyline(V,N,true);
}

/* ========= DFT ========= */
function dft(pts){
  const N=pts.length;
  let cx=0,cy=0; for(const p of pts){cx+=p.x; cy+=p.y} cx/=N; cy/=N;
  const z=pts.map(p=>({re:p.x-cx, im:p.y-cy}));
  const C=[];
  for(let k=-Math.floor(N/2); k<=Math.floor(N/2); k++){
    let re=0, im=0;
    for(let n=0;n<N;n++){ const a=-2*Math.PI*k*n/N;
      re += z[n].re*Math.cos(a) - z[n].im*Math.sin(a);
      im += z[n].re*Math.sin(a) + z[n].im*Math.cos(a); }
    re/=N; im/=N;
    C.push({id:k+N, k, amp:Math.hypot(re,im), phase:Math.atan2(im,re), cx, cy,
            enabled:true, modK:0, ampScale:1, phaseOffset:0});
  }
  return C.sort((a,b)=>b.amp-a.amp);
}

/* ========= Build & helpers ========= */
function build(shape='heart'){
  const N=1024;
  points = shape==='heart'?heart(N):
           shape==='star'?star5(N):
           shape==='triangle'?poly(3,N):
           shape==='square'?poly(4,N):
           shape==='pentagon'?poly(5,N):
           shape==='hexagon'?poly(6,N):
           shape==='infinity'?infinityC(N):
           shape==='circle'?circle(N):batmanS(N);
  order = dft(points);
  t=0; trace.length=0; lastCycle=0; startPt=null; cumPhaseDeg=0;
  applyDisableFirst();
}
function firstEnabled(){
  for(const c of order){ if(c.enabled) return c; }
  return null;
}

/* ========= AnimaciÃ³n ========= */
function frame(dt){
  if(running) t += dt*speed;

  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,W,H);

  const chosen = order.filter(c=>c.enabled).slice(0,circlesN);
  let x=(order[0]?.cx||W/2), y=(order[0]?.cy||H/2);

  ctx.lineWidth=1*dpi;
  for(const c of chosen){
    const freq=c.k+c.modK, phase=c.phase+c.phaseOffset, amp=c.amp*c.ampScale*zoom;
    const ang=2*Math.PI*freq*(t%1)+phase, vx=amp*Math.cos(ang), vy=amp*Math.sin(ang);
    ctx.strokeStyle='rgba(255,255,255,.18)';
    ctx.beginPath(); ctx.arc(x,y,amp,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+vx,y+vy); ctx.stroke();
    x+=vx; y+=vy;
  }

  if(showTrace){
    trace.push({x,y,color:currentColor});
    if(trace.length>traceMax) trace.splice(0, trace.length-traceMax);
    ctx.lineWidth=2.2*dpi;
    for(let i=1;i<trace.length;i++){
      ctx.strokeStyle=trace[i].color;
      ctx.beginPath(); ctx.moveTo(trace[i-1].x,trace[i-1].y); ctx.lineTo(trace[i].x,trace[i].y); ctx.stroke();
    }
  }
  ctx.fillStyle=currentColor; ctx.beginPath(); ctx.arc(x,y,2.6*dpi,0,Math.PI*2); ctx.fill();

  // gestiÃ³n de ciclos
  const cycleNow = Math.floor(t);
  const closedBase = cycleNow > lastCycle;
  const closedGeom = startPt && (Math.hypot(x-startPt.x,y-startPt.y) < 2.5*dpi) && (t-lastCycle>0.6);

  if(!startPt) startPt = {x,y};

  if(closedBase){
    lastCycle = cycleNow;
    onCycleBaseClosed();
  }

  if(trailMode===2){
    // â€œhasta cierre largoâ€
    if(perCycle.phaseEnabled){
      // cierre cuando la fase acumulada vuelve a 0Â° (mÃºltiplo de 360)
      if(mod360(cumPhaseDeg)===0 && cumPhaseDeg>0){
        onLongClosure();
      }
    } else if(closedGeom){
      onLongClosure();
    }
  }
}
function loop(now){ const dt=Math.min(0.05,(now-(loop.t0||now))/1000); loop.t0=now; frame(dt); requestAnimationFrame(loop); }
function mod360(d){ const m=((d%360)+360)%360; return (m<1 || m>359)?0:m; }

/* ========= Cierres ========= */
function onCycleBaseClosed(){
  // rastro de 1 ciclo
  if(trailMode===1) trace.length=0;

  // aplicar mods por ciclo (fase, amp, zoom, color)
  const target = firstEnabled();
  if(!target) return;

  if(perCycle.phaseEnabled){
    const d=perCycle.phaseStepDeg;
    target.phaseOffset += deg2rad(d);
    cumPhaseDeg += d; // para cierre largo
  }
  if(perCycle.ampEnabled){
    target.ampScale *= perCycle.ampScaleStep;
    // ciclo: si supera 1.6 â†’ reinicia pequeÃ±o (0.3)
    if(target.ampScale > 1.6) target.ampScale = 0.3;
  }
  if(perCycle.zoomEnabled){
    zoom = clamp(zoom*perCycle.zoomStep, 0.5, 3);
  }
  if(perCycle.colorEnabled){
    nextHue();
  }
}

function onLongClosure(){
  // cierre largo â†’ limpiar rastro y reanclar inicio
  trace.length = 0;
  startPt = null;
  cumPhaseDeg = 0; // reiniciamos el acumulador para el prÃ³ximo â€œmacro-cicloâ€
}

/* ========= Color ========= */
function nextHue(){ const h=(Math.random()*360)|0; currentColor=`hsl(${h},100%,85%)`; }

/* ========= Botones ========= */
const btnCircles=$('#btnCircles'), btnShape=$('#btnShape'), btnSpeed=$('#btnSpeed'), btnTrail=$('#btnTrail'),
      btnPhase=$('#btnPhase'), btnAmp=$('#btnAmp'), btnZoomC=$('#btnZoomC'), btnColorC=$('#btnColorC'),
      btnOff1=$('#btnOff1'), btnReset=$('#btnReset'), btnPlay=$('#btnPlay'), btnSave=$('#btnSave');

function setActive(btn,on){ btn.classList.toggle('active', !!on); }

btnCircles.addEventListener('click', ()=>{
  circlesIdx=(circlesIdx+1)%circlesPresets.length;
  circlesN=circlesPresets[circlesIdx];
  btnCircles.textContent = circlesIdx===0?'â—':(circlesIdx===1?'â—â—':'â—â—â—');
});

btnShape.addEventListener('click', ()=>{
  shapeIdx=(shapeIdx+1)%SHAPES.length;
  btnShape.textContent = SHICON[SHAPES[shapeIdx]];
  build(SHAPES[shapeIdx]); // reset de parÃ¡metros aplicado en build()
});

btnSpeed.addEventListener('click', ()=>{
  speedIdx=(speedIdx+1)%speedPresets.length; speed=speedPresets[speedIdx];
  btnSpeed.textContent = ['ğŸ¢','ğŸ™‚','ğŸ‡'][speedIdx];
});

btnTrail.addEventListener('click', ()=>{
  // 0 = off, 1 = 1 ciclo, 2 = hasta cierre largo
  trailMode=(trailMode+1)%3;
  showTrace = trailMode!==0;
  btnTrail.textContent = ['â—¯','â—”','âˆ'][trailMode];
  if(trailMode===0) trace.length=0;
});

btnPhase.addEventListener('click', ()=>{ perCycle.phaseEnabled=!perCycle.phaseEnabled; setActive(btnPhase, perCycle.phaseEnabled); });
btnAmp  .addEventListener('click', ()=>{ perCycle.ampEnabled  =!perCycle.ampEnabled;   setActive(btnAmp,   perCycle.ampEnabled); });
btnZoomC.addEventListener('click', ()=>{ perCycle.zoomEnabled=!perCycle.zoomEnabled; setActive(btnZoomC, perCycle.zoomEnabled); });
btnColorC.addEventListener('click',()=>{ perCycle.colorEnabled=!perCycle.colorEnabled; setActive(btnColorC, perCycle.colorEnabled); });

function applyDisableFirst(){
  if(!order.length) return;
  order.forEach((c,i)=> c.enabled = (i!==0) || !disableFirst);
}
btnOff1.addEventListener('click', ()=>{
  disableFirst = !disableFirst;
  setActive(btnOff1, disableFirst);
  applyDisableFirst();
});

btnReset.addEventListener('click', ()=>{
  // restaurar todo a estado limpio de la figura actual
  order.forEach(c=>{ c.ampScale=1; c.phaseOffset=0; c.modK=0; c.enabled=true; });
  disableFirst=false; setActive(btnOff1,false);
  zoom=1; trace.length=0; cumPhaseDeg=0; startPt=null; lastCycle=Math.floor(t);
  perCycle.phaseEnabled=true; perCycle.ampEnabled=false; perCycle.zoomEnabled=false; perCycle.colorEnabled=true;
  setActive(btnPhase,true); setActive(btnAmp,false); setActive(btnZoomC,false); setActive(btnColorC,true);
});

btnPlay.addEventListener('click', ()=>{ running=!running; btnPlay.textContent = running?'âšâš':'â–¶ï¸'; });

btnSave.addEventListener('click', ()=>{
  const url=cvs.toDataURL('image/png'); const a=document.createElement('a');
  a.href=url; a.download='orbitas.png'; a.click();
});

/* ========= Bloquear zoom/pan manual ========= */
cvs.addEventListener('touchstart', e=>{ e.preventDefault(); }, {passive:false});
cvs.addEventListener('touchmove',  e=>{ e.preventDefault(); }, {passive:false});
cvs.addEventListener('gesturestart', e=>e.preventDefault());

/* ========= Init ========= */
build('heart');
btnShape.textContent=SHICON[SHAPES[shapeIdx]];
btnCircles.textContent='â—â—â—';          // 6 (preset medio visual = â€œdos bolitasâ€ â†’ usamos 3 para consistencia)
btnSpeed.textContent=['ğŸ¢','ğŸ™‚','ğŸ‡'][speedIdx];
btnTrail.textContent='â—”';
setActive(btnPhase,true); setActive(btnColorC,true);
requestAnimationFrame(loop);
</script>
</body>
</html>
