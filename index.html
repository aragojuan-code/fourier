<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Foto → Línea → Epiciclos de Fourier</title>
<style>
  :root{
    --bg:#0f141b; --panel:#121a23; --ink:#e6eef7; --muted:#9fb3c9; --accent:#6ab0ff;
    --good:#38bdf8; --warn:#fbbf24;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{display:grid;grid-template-columns:320px 1fr;min-height:100vh}
  @media (max-width:900px){.wrap{grid-template-columns:1fr;grid-template-rows:auto 1fr}}
  aside{padding:16px;border-right:1px solid rgba(230,238,247,.08);background:var(--panel)}
  main{position:relative}
  h1{font-size:18px;margin:0 0 12px}
  .card{background:#0e1520;border:1px solid rgba(230,238,247,.08);border-radius:12px;padding:12px;margin-bottom:12px}
  label{font-size:13px;color:var(--muted)}
  input[type="file"]{width:100%}
  button{background:#101722;border:1px solid rgba(230,238,247,.12);color:var(--ink);padding:10px 12px;border-radius:10px;cursor:pointer}
  button.primary{background:var(--accent);border-color:transparent;color:#06121e;font-weight:600}
  button:disabled{opacity:.5;cursor:not-allowed}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .hint{color:var(--muted);font-size:12px;margin-top:6px}
  canvas{width:100%;height:100%;display:block;background:#000}
  .overlay{position:absolute;inset:0;pointer-events:none}
  .small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>Foto → Epiciclos</h1>

    <div class="card">
      <label>Imagen (de frente funciona mejor)</label>
      <input id="file" type="file" accept="image/*"/>
      <div class="hint">Consejo: usa fondo contrastado. La app detecta el contorno principal.</div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <label>Umbral bordes (Sobel)</label><span id="thrVal" class="small">128</span>
      </div>
      <input id="thr" type="range" min="20" max="255" value="128" step="1" style="width:100%">
      <div class="row" style="margin-top:8px;gap:10px">
        <button id="detect">Detectar contorno</button>
        <button id="clear">Limpiar</button>
      </div>
      <div class="hint">Ajusta el umbral si sale demasiado ruido o muy poco contorno.</div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <label>Pts muestreados</label><span id="ptsVal" class="small">512</span>
      </div>
      <input id="pts" type="range" min="128" max="2048" value="512" step="64" style="width:100%">
      <div class="row" style="justify-content:space-between;margin-top:8px">
        <label>Armónicos</label><span id="harmVal" class="small">64</span>
      </div>
      <input id="harm" type="range" min="8" max="256" value="64" step="8" style="width:100%">
      <div class="row" style="margin-top:8px;gap:10px">
        <button class="primary" id="fourier" disabled>Fourier → Epiciclos</button>
        <button id="pause" disabled>Pausa</button>
      </div>
      <div class="hint">Más armónicos = más detalle. Con 64–128 ya se ve muy bien.</div>
    </div>

    <div class="card">
      <div class="row" style="gap:8px">
        <label><input id="showCircles" type="checkbox" checked> Mostrar círculos</label>
        <label><input id="showTrace" type="checkbox" checked> Trazar línea</label>
        <label><input id="hidePhoto" type="checkbox" checked> Ocultar foto</label>
      </div>
    </div>

    <div class="small">Hecho con ♥ en Canvas + DFT (sin librerías).</div>
  </aside>

  <main>
    <canvas id="view"></canvas>
    <canvas id="overlay" class="overlay"></canvas>
  </main>
</div>

<script>
const file = document.getElementById('file');
const thr = document.getElementById('thr'); const thrVal = document.getElementById('thrVal');
const pts = document.getElementById('pts'); const ptsVal = document.getElementById('ptsVal');
const harm = document.getElementById('harm'); const harmVal = document.getElementById('harmVal');
const detectBtn = document.getElementById('detect');
const fourierBtn = document.getElementById('fourier');
const pauseBtn = document.getElementById('pause');
const showCircles = document.getElementById('showCircles');
const showTrace = document.getElementById('showTrace');
const hidePhoto = document.getElementById('hidePhoto');

const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const octx = overlay.getContext('2d');

let img = new Image();
let W=0,H=0, dpi=window.devicePixelRatio||1;

let edgeMap=null, pathPts=[], resampled=[], coeffs=[], order=[];
let running=false, t=0, paused=false;

function resize(){
  const rect = canvas.parentElement.getBoundingClientRect();
  W = Math.floor(rect.width*dpi); H = Math.floor(rect.height*dpi);
  canvas.width=W; canvas.height=H; overlay.width=W; overlay.height=H;
  draw();
}
window.addEventListener('resize', resize);

function draw(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,W,H);
  if(img && img.loaded && !hidePhoto.checked){
    ctx.drawImage(img, (W-img.w)>>1, (H-img.h)>>1, img.w, img.h);
  }
  // preview: edges / outline
  octx.setTransform(1,0,0,1,0,0);
  octx.clearRect(0,0,W,H);
  octx.lineWidth=2*dpi;
  octx.strokeStyle='#6ab0ff';
  if(pathPts.length){
    octx.beginPath();
    const offX=(W-img.w)>>1, offY=(H-img.h)>>1;
    octx.moveTo(pathPts[0].x+offX, pathPts[0].y+offY);
    for(let i=1;i<pathPts.length;i++){
      octx.lineTo(pathPts[i].x+offX, pathPts[i].y+offY);
    }
    octx.closePath(); octx.stroke();
  }
}

file.addEventListener('change', e=>{
  const f=e.target.files?.[0]; if(!f) return;
  const url=URL.createObjectURL(f);
  img.onload=()=>{
    img.loaded=true;
    // Limit size to fit viewport
    const maxW = Math.min(900*dpi, (canvas.parentElement.clientWidth||900)*dpi*0.9);
    const maxH = Math.min(900*dpi, (canvas.parentElement.clientHeight||700)*dpi*0.9);
    const s = Math.min(maxW/img.width, maxH/img.height, 1);
    img.w = Math.floor(img.width*s);
    img.h = Math.floor(img.height*s);
    resize();
    draw();
    fourierBtn.disabled = true;
  };
  img.src=url;
});

thr.addEventListener('input', ()=>{thrVal.textContent=thr.value});
pts.addEventListener('input', ()=>{ptsVal.textContent=pts.value});
harm.addEventListener('input', ()=>{harmVal.textContent=harm.value});

detectBtn.addEventListener('click', ()=>{
  if(!img.loaded) return;
  // 1) dibujar imagen en un buffer
  const buf = document.createElement('canvas');
  buf.width = img.w; buf.height = img.h;
  const bctx = buf.getContext('2d');
  bctx.drawImage(img,0,0,img.w,img.h);
  const im = bctx.getImageData(0,0,img.w,img.h);
  const gray = toGray(im.data);
  const sob = sobel(gray, img.w, img.h);
  edgeMap = threshold(sob, +thr.value);
  pathPts = traceLongest(edgeMap, img.w, img.h);
  draw();
  fourierBtn.disabled = pathPts.length<50;
});

fourierBtn.addEventListener('click', ()=>{
  if(pathPts.length<3) return;
  // 2) resample
  resampled = resample(pathPts, +pts.value);
  // 3) DFT
  coeffs = dft(resampled);
  // 4) ordenar por amplitud para dibujar primero los grandes
  order = [...coeffs].sort((a,b)=>b.amp - a.amp).slice(0, +harm.value);
  running = true; paused=false; t=0; animate();
  pauseBtn.disabled=false;
});

pauseBtn.addEventListener('click', ()=>{
  paused=!paused;
  pauseBtn.textContent = paused? 'Reanudar':'Pausa';
  if(!paused) animate();
});

hidePhoto.addEventListener('change', draw);

document.getElementById('clear').addEventListener('click', ()=>{
  edgeMap=null; pathPts=[]; resampled=[]; coeffs=[]; order=[];
  running=false; paused=false; t=0; pauseBtn.disabled=true;
  draw();
});

// === Procesado de imagen ===

function toGray(rgba){
  const n=rgba.length/4, out=new Uint8ClampedArray(n);
  for(let i=0;i<n;i++){
    const r=rgba[i*4], g=rgba[i*4+1], b=rgba[i*4+2];
    out[i] = (0.299*r + 0.587*g + 0.114*b)|0;
  }
  return out;
}

function sobel(gray,w,h){
  const out=new Float32Array(w*h);
  const gxK=[-1,0,1,-2,0,2,-1,0,1];
  const gyK=[-1,-2,-1,0,0,0,1,2,1];
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let gx=0,gy=0,idx=0;
      for(let ky=-1;ky<=1;ky++){
        for(let kx=-1;kx<=1;kx++){
          const v=gray[(y+ky)*w + (x+kx)];
          gx += v*gxK[idx]; gy += v*gyK[idx]; idx++;
        }
      }
      out[y*w+x]=Math.hypot(gx,gy);
    }
  }
  // normalizar a 0..255
  let max=1; for(let i=0;i<out.length;i++) if(out[i]>max) max=out[i];
  const o=new Uint8ClampedArray(w*h);
  for(let i=0;i<out.length;i++) o[i]=(out[i]/max*255)|0;
  return o;
}

function threshold(img,thr){
  const out=new Uint8Array(img.length);
  for(let i=0;i<img.length;i++) out[i]= img[i]>=thr ? 1:0;
  return out; // mapa binario
}

// Tracing 8-conectado del contorno más largo
function traceLongest(bin,w,h){
  const visited=new Uint8Array(bin.length);
  const dirs=[[1,0],[1,1],[0,1],[-1,1],[-1,0],[-1,-1],[0,-1],[1,-1]];
  function trace(x0,y0){
    let x=x0,y=y0, lastDir=0, pts=[];
    for(let iter=0;iter< w*h; iter++){
      const idx=y*w+x;
      if(!bin[idx] || visited[idx]) break;
      visited[idx]=1;
      pts.push({x,y});
      // buscar siguiente vecino (prioriza mantener dirección)
      let found=false;
      for(let k=0;k<8;k++){
        const d=(lastDir + k + 7)%8; // pequeña inercia
        const nx=x+dirs[d][0], ny=y+dirs[d][1];
        if(nx<=0||ny<=0||nx>=w-1||ny>=h-1) continue;
        const nidx=ny*w+nx;
        if(bin[nidx] && !visited[nidx]){
          x=nx; y=ny; lastDir=d; found=true; break;
        }
      }
      if(!found) break;
      // cierre
      if(pts.length>50 && Math.hypot(pts[0].x-x, pts[0].y-y)<2) break;
    }
    return pts;
  }
  const contours=[];
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const idx=y*w+x;
      if(bin[idx] && !visited[idx]){
        const c=trace(x,y);
        if(c.length>20) contours.push(c);
      }
    }
  }
  if(!contours.length) return [];
  // elegir el más largo
  let best=contours[0];
  for(const c of contours) if(c.length>best.length) best=c;
  // suavizar y cerrar
  return smooth(closePath(best));
}
function closePath(pts){
  const out=pts.slice();
  if(Math.hypot(out[0].x - out.at(-1).x, out[0].y - out.at(-1).y)>1) out.push({x:pts[0].x,y:pts[0].y});
  return out;
}
function smooth(pts){
  // moving average simple
  const k=3, out=[];
  for(let i=0;i<pts.length;i++){
    let sx=0, sy=0, c=0;
    for(let j=-k;j<=k;j++){
      const p=pts[(i+j+pts.length)%pts.length];
      sx+=p.x; sy+=p.y; c++;
    }
    out.push({x:sx/c, y:sy/c});
  }
  return out;
}

// Resamplear N puntos equiespaciados por longitud de arco
function resample(pts, N){
  // acumular longitudes
  const L=[0]; let sum=0;
  for(let i=1;i<pts.length;i++){
    sum+=Math.hypot(pts[i].x-pts[i-1].x, pts[i].y-pts[i-1].y);
    L.push(sum);
  }
  const total=sum;
  const out=[];
  for(let i=0;i<N;i++){
    const d=i/ N * total;
    // buscar segmento
    let j=1; while(j<L.length && L[j]<d) j++;
    const t=(d-L[j-1])/(L[j]-L[j-1] || 1);
    const x=pts[j-1].x*(1-t)+pts[j].x*t;
    const y=pts[j-1].y*(1-t)+pts[j].y*t;
    // centrar en canvas
    const offX=(W-img.w)>>1, offY=(H-img.h)>>1;
    out.push({x:x+offX, y:y+offY});
  }
  return out;
}

// === DFT & Epiciclos ===
function dft(points){
  // convertir a números complejos centrados
  const N=points.length;
  let cx=0,cy=0; for(const p of points){cx+=p.x; cy+=p.y}
  cx/=N; cy/=N;
  const z=points.map(p=>({re:p.x-cx, im:p.y-cy}));

  const coeff=[];
  // frecuencias enteras negativas y positivas
  for(let k= -Math.floor(N/2); k<=Math.floor(N/2); k++){
    let re=0, im=0;
    for(let n=0;n<N;n++){
      const ang = -2*Math.PI*k*n/N;
      const cos=Math.cos(ang), sin=Math.sin(ang);
      re += z[n].re*cos - z[n].im*sin;
      im += z[n].re*sin + z[n].im*cos;
    }
    re/=N; im/=N;
    const amp=Math.hypot(re,im);
    const phase=Math.atan2(im,re);
    coeff.push({k, re, im, amp, phase, cx, cy});
  }
  return coeff;
}

function animate(){
  if(!running || paused) return;
  t += 1/60; // segundos aprox (no importa la base)
  const T=1; // periodo 1
  const tt = (t%T)/T;

  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,W,H);

  // reconstrucción
  let x = coeffs[0]?.cx || W/2, y = coeffs[0]?.cy || H/2;
  const path=[];
  if(showCircles.checked){
    ctx.lineWidth=1*dpi; ctx.strokeStyle='rgba(255,255,255,.25)';
  }
  // ordenar por amplitud seleccionada
  const chosen = order.slice(0, +harm.value);

  for(const c of chosen){
    const freq=c.k;
    const ang = 2*Math.PI*freq*tt + c.phase;
    const vx = c.amp*Math.cos(ang);
    const vy = c.amp*Math.sin(ang);
    if(showCircles.checked){
      ctx.beginPath(); ctx.arc(x,y,c.amp,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+vx, y+vy); ctx.stroke();
    }
    x += vx; y += vy;
    path.push([x,y]);
  }

  if(showTrace.checked){
    ctx.lineWidth=2*dpi; ctx.strokeStyle='#e6eef7';
    ctx.beginPath();
    if(path.length){
      ctx.moveTo(path[0][0], path[0][1]);
      for(let i=1;i<path.length;i++) ctx.lineTo(path[i][0], path[i][1]);
      ctx.stroke();
    }
  }

  requestAnimationFrame(animate);
}

// start
resize();

// util
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
</script>
</body>
</html>
